
#include<iostream>
#include<thread>
#include<shared_mutex>
#include<mutex>
#include<chrono>
#include<vector>
long TIMES = 5000000L;
long count = 0;

std::shared_mutex mt;

void counter() {
    for(long I = 1; I <= TIMES; I++) {
        {
            std::unique_lock<std::shared_mutex> lock(mt);
            count++;
        }
        std::this_thread::sleep_for(std::chrono::milliseconds(500));
    }
}

void displayCount(int id) {
    for(long I = 1; I <= TIMES; I++) {
        {
            std::shared_lock<std::shared_mutex> lock(mt);
            std::cout << "At " << id << ":" << count << std::endl; 
        }
        std::this_thread::sleep_for(std::chrono::milliseconds(500));
    }
}




.......



#include <iostream>
#include <vector>
#include <unistd.h>
#include <sys/wait.h>
#include <cstring>
#include <string>

using namespace std;

class Prescription {
private:
    string PrescriptionId;
    int Dosage;
public:
    Prescription(string id, int dose) : PrescriptionId(id), Dosage(dose) {}

    string getPrescriptionId() const { return PrescriptionId; }
    int getDosage() const { return Dosage; }
};

void client(int write_to_server, int read_from_server) {
    vector<Prescription> prescriptions = {
        Prescription("RX001", 4), 
        Prescription("RX002", 5), 
        Prescription("RX003", 6), 
        Prescription("RX004", 15), 
        Prescription("RX005", 1)
    };

    int size = prescriptions.size();
    int arr[100];

    // Filling the array with dosage data
    for (int i = 0; i < size; ++i) {
        arr[i] = prescriptions[i].getDosage();
    }

    cout << "Client sending dosages: ";
    for (int i = 0; i < size; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;

    // Send data to server
    write(write_to_server, &size, sizeof(size));
    write(write_to_server, arr, sizeof(int) * size);

    // Read result from server
    int sum;
    read(read_from_server, &sum, sizeof(sum));
    cout << "Client received sum from server: " << sum << endl;

    close(write_to_server);
    close(read_from_server);
}

void server(int read_from_client, int write_to_client) {
    int buffer[100];
    int size;
    int sum = 0;

    // Read size and data from client
    read(read_from_client, &size, sizeof(size));
    read(read_from_client, buffer, sizeof(int) * size);

    cout << "Server received dosages: ";
    for (int i = 0; i < size; ++i) {
        cout << buffer[i] << " ";
        sum += buffer[i];
    }
    cout << endl;

    cout << "Server calculated sum: " << sum << endl;

    // Send sum back to client
    write(write_to_client, &sum, sizeof(sum));

    close(read_from_client);
    close(write_to_client);
}

int main() {
    int pipe_client_to_server[2];
    int pipe_server_to_client[2];

    // Create pipes
    if (pipe(pipe_client_to_server) == -1 || pipe(pipe_server_to_client) == -1) {
        perror("Pipe creation failed");
        return 1;
    }

    pid_t pid = fork();
    if (pid == -1) {
        perror("Fork failed");
        return 1;
    }

    if (pid == 0) {  // Child process (Client)
        close(pipe_client_to_server[0]);
        close(pipe_server_to_client[1]);
        client(pipe_client_to_server[1], pipe_server_to_client[0]);
        exit(0);
    } else {  // Parent process (Server)
        close(pipe_client_to_server[1]);
        close(pipe_server_to_client[0]);
        server(pipe_client_to_server[0], pipe_server_to_client[1]);
        wait(nullptr);  // Wait for child process
    }

    return 0;
}

...........

#include <iostream>
#include <vector>
#include <thread>
#include <mutex>

using namespace std;

class Prescription {
private:
    string prescriptionId;
    double dosage;

public:
    Prescription(const string& prescriptionId, double dosage) : prescriptionId(prescriptionId), dosage(dosage) {}

    double getDosage() const {
        return dosage;
    }
};

// Shared variables for communication
vector<double> sharedData;
double totalSum = 0;
bool dataReady = false;
bool resultReady = false;

// Mutex to protect shared variables
mutex mtx;

void calculatePartialSum(const vector<double>& data, int start, int end, double& partialSum) {
    partialSum = 0;
    for (int i = start; i < end; ++i) {
        partialSum += data[i];
    }
}

void client(const vector<Prescription>& prescriptions) {
    vector<double> buffer;
    for (const auto& prescription : prescriptions) {
        buffer.push_back(prescription.getDosage());
    }

    {
        lock_guard<mutex> lock(mtx);
        sharedData = buffer;
        dataReady = true;
        cout << "Client: Sending data to server...\n";
    }

    // Busy wait until the result is ready
    while (true) {
        {
            lock_guard<mutex> lock(mtx);
            if (resultReady) {
                cout << "Client: Received total sum from server: " << totalSum << endl;
                break;
            }
        }
    }
}

void server() {
    vector<double> data;

    // Busy wait until the data is ready
    while (true) {
        {
            lock_guard<mutex> lock(mtx);
            if (dataReady) {
                data = sharedData;
                cout << "Server: Received data from client...\n";
                break;
            }
        }
    }

    double firstHalfSum = 0, secondHalfSum = 0;

    // Calculate partial sums in separate threads
    thread t1(calculatePartialSum, cref(data), 0, data.size() / 2, ref(firstHalfSum));
    thread t2(calculatePartialSum, cref(data), data.size() / 2, data.size(), ref(secondHalfSum));

    t1.join();
    t2.join();

    {
        lock_guard<mutex> lock(mtx);
        totalSum = firstHalfSum + secondHalfSum;
        resultReady = true;
        cout << "Server: Calculated total sum: " << totalSum << endl;
    }
}

int main() {
    // Initialize Prescription objects
    vector<Prescription> prescriptions = {
        Prescription("p1", 50.5),
        Prescription("p2", 25.0),
        Prescription("p3", 75.5),
        Prescription("p4", 40.0),
        Prescription("p5", 30.0)
    };

    // Start client and server threads
    thread clientThread(client, cref(prescriptions));
    thread serverThread(server);

    clientThread.join();
    serverThread.join();

    return 0;
}
